# Шпаргалка для учеников Стёпы по языку Python

---

# Вывод в консоль

## Вывод текста :
### `print("<текст>")` 

Текст, который мы хотим вывести, обязательно должен быть в кавычках. Это связано с тем, что питон воспринимает текст без кавычек как код, то есть, как какие-то инструкции, которые ему надо выполнить. Но если мы обернем текст в кавычки, то питон поймет, что это текст, который, например, можно напечатать. Например,

```py
print("Привет всем!")

# >>> Привет всем!
```

---

## Вывод нескольких кусков текста друг за другом :
### `print("<текст>", "<текст>", "<текст>")`

Если у нас есть несколько разных строк (так называют текст, который можно вывести или хранить в переменной), и мы хотим вывести их на одной строке через пробел, то мы можем перечислить их все внутри скобочек после `print`. Например,

```py
print("Привет", "всем!")

# >>> Привет всем!
```

### `print("<текст>" + "<текст>")`

Другой способ вывести несколько строк, но не через пробел, это соединить их с помощью знака `+`. Например,

```py
print("Привет" + "всем!")

# >>> Приветвсем!
```

Только тогда надо не забыть написать пробелы, если мы хотим, чтобы они там были. Если мы напишем несколько строк через запятую в `print`, тогда питон поставит пробелы автоматически, но если мы будем соединять строки с помощью `+`, тогда строки соединятся как есть, без пробелов.

---

# Переменные

## Создание переменной : 
### `<имя_переменной> = <значение>`

Имя переменной может быть любым сочетанием латинских символов, нижних подчеркиваний (`_`) и цифр, но не может начинаться с цифры.

Пример возможных имен переменных:

* `abc`
* `QWERTY`
* `userPermissions`
* `inventory_manager`
* `result`
* `_hidden_property`
* `EditorObject`

Чаще всего я называю переменные, разделяя слова нижними подчеркиваниями.

Значение переменной может быть числовым, текстовым (такой текст принято называть "строками") или логическим. Пример возможных значений переменных:

* `15.4`
* `300000`
* `"Error: unexpected token"`
* `"Сохранить и выйти?"`
* `True` (логическое "ДА")
* `False` (логическое "НЕТ")
* `3`

После того, как выполнится стррочка, содержащая создание переменной, она появится в нашей программе и будет содержать значение, которое мы ей присвоили, пока мы не изменим его.

---

## Обновление переменной :
### `<имя переменной> = <новое значение>`
### `<имя переменной> += <число или строка>`
### `<имя переменной> -= <число>`
### `<имя переменной> *= <число>`
### `<имя переменной> /= <число>`

Мы, конечно, можем взять существующую переменную и просто записать новое значение в нее. Более того, мы можем взять ее и использовать в качестве части значения, которое мы записываем. Например, 

```py
# Создаем переменную
counter = 0

# Обновляем переменную
counter = counter + 1
```

Но помимо этого, мы можем использовать специальные *операторы* для того, чтобы прибавить, отнять или как-то еще поменять значение переменной.

```py
# Создаем переменную
acc = 15

# Умножаем на два
acc *= 2 

# Прибавляем десять
acc += 10

# Выводим значение
print(acc)
```

---

## Вывод переменных :
### `print(<имя переменной>)`

Если мы хотим вывести на экран значение переменной, его достаточно написать внутри скобочек после `print`.

```py
counter = 0

counter += 1
counter += 1
counter += 1

print(counter)

# >>> 3
```

Если использовать вывод строки одновременно с выводом переменной, то можно "вклеивать" их таким образом в текст:

```py
age = 20

print("Мне", age, "лет.")

# >>> Мне 20 лет.
```

---

# Преобразования значений

## Преобразование числа в строку (текст)
### `str(<число>)` или `str(<переменная>)`

Иногда мы можем столкнуться с ситуацией, когда мы хотим преобразовать число в строку: например, чтобы перебрать его по цифрам (и точке, если она есть!) или чтобы соединить с другой строкой. В такой ситуации мы можем обернуть его в `str(` и `)`. Это точно так же работает с переменными.

```py
text = str(1234)

# То же самое, что
text = "1234"
```

```py
age = 20

print("Мне " + str(age) + " лет.")

# >>> Мне 20 лет.
```

---

## Преобразование строки в число
### `float(<строка>)`

Иногда может случиться обратная ситуация: у нас есть строка, содержащая число, и нам нужно это число из нее вытащить. Например, это число ввел пользователь, а весь пользовательский ввод с клавиатуры сохраняется как строки. Для этого можно обернуть строку в `float(` и `)` (или в `int()`, но строго для целых чисел).

```py
text = "12.34"

number = float(text)

print(number * 2)

# >>> 24.68
```

---

## Округление 
### `round(<число>)`

Если мы имеем дробное число и хотим округлить его до ближайшего целого, мы можем обернуть его в `round(` и `)`.

```py
number = 3.1415

print(round(number))

# >>> 3
```

```py
number = 4.99

print(round(number))

# >>> 5
```

---

# Ввод из консоли

## Считывание ввода пользователя в переменную:
### `<имя переменной> = input()`

Чаще всего, если мы хотим чтобы пользователь набрал что-то на клавиатуре, то нам с этим набранным текстом придется потом работать. Поэтому хорошим решением в такой ситуации будет сохранить этот текст в переменную (лучше в новую). Это делается так же, как и с записью чисел или строк в переменные, только вместо числа или строки будет `input()` — специальная функция, которая останавливает программу, ждет, пока пользователь введет текст и нажмет "Enter", а затем превращается в то, что ввел пользователь.

Например, рассмотрим следующий код:

```py
print("Привет. Как тебя зовут?")

name = input()

print("Рад знакомству,", name, "!")
```

Программа сначала напечает `Привет. Как тебя зовут?`, а затем остановится, чтобы пользователь смог напечатать ответ. После того, как пользователь напишет свое имя и нажмет "Enter", то, что он написал, встанет вместо `input()` в коде и запишется в переменную `name` как обычный текст. 

Например, если я запущу эту программу и напишу "Стёпа", то код можно было бы представить себе так:

```py
print("Привет. Как тебя зовут?")

name = "Стёпа"

print("Рад знакомству,", name, "!")
 
# >>> Рад знакомству, Стёпа !
```

---

# Условия и ветвление

## Выполнить код только если переменная равна чему-то:
### `if <переменная> == <значение>:`

В наших программах мы можем сделать так, чтобы какой-то участок кода запустился только если в определенной переменной содержится определнное значение. Например, если пользователь ввел правильный ответ на вопрос.

```py
print("Сколько будет 9 * 9?")

answer = input()

if answer == "81":

    print("Правильно!")
```

В этой программе, если пользователь введет число 81, то в переменной `answer` будет содержаться строка `"81"`, и условие `answer == "81"` будет соблюдено, а значит, выполнится код, идущий после двоеточия. Если же пользователь введет что угодно, кроме "81", то условие не будет соблюдено, и код не запустится.

> ***Важно!***
>
> В условиях, если мы хотим проверить равенство переменной с чем-нибудь (с другой переменной, числом или строкой), то **обязательно** надо использовать два знака равно: `==`. Это связано с тем, что в питоне один знак равно (`=`) всегда значит "записать", а два знака равно значит "сравнить", и один знак равно всегда используется только в случаях, когда нам нужно записать что-нибудь в переменную или куда-нибудь еще.

>

---

## Выполнить другой код если условие в `if` не соблюдено:
### `else:`

Модифицируем предыдущий пример: пользователь ввел неправильный ответ, после чего мы захотим вывести об этом сообщение. Для этого, после конструкции `if` нужно добавить `else` с двоеточием, и если (и только если!) код после `if`-а не запустился, то автоматически запустится код после `else`.

```py
print("Сколько будет 9 * 9?")

answer = float(input())

if answer == 81:

    print("Правильно!")

else:

    print("Неправильно!")
```

---

## Другие условия:
### `<значение A> == <значение B>`
### `<значение A> != <значение B>`
### `<значение A> > <значение B>`
### `<значение A> < <значение B>`
### `<значение A> >= <значение B>`
### `<значение A> <= <значение B>`

Не всегда мы будем хотеть проверять, равно ли что-то чему-то еще. Может, мы хотим проверить, наоборот, что оно *не равно*. Существует множество операторов для разных проверок:

* `==` — A равно B
* `!=` — A не равно B
* `>` — A больше B
* `<` — А меньше B
* `>=` — A больше B или A равно B
* `<=` — A меньше B или A равно B

---

## Несколько последовательных условий:
### `if <условие>:`
### `elif <второе условие>:`
### `elif <третье условие>:`
### `elif <четвертое условие>:`
### `else:`

Может быть, мы решили после проверки внутри `if`-а сделать еще одну проверку. Можно было бы написать `else:`, а потом еще один `if` внутри, но для этого существует сокращение `elif`, которое позволяет проверить несколько условий, но при этом **каждое условие проверяется только если предыдущее не было соблюдено**.

```py
print("Сколько будет 9 * 9?")

answer = float(input())

if answer == 81:

    print("Правильно!")

elif answer < 81:

    print("Неправильно. Правильное число больше")

elif answer > 81:

    print("Неправильно. Правильное число меньше")
```

---

# Циклы

## Бесконечный цикл
### `while True:`

Иногда нам нужно чтобы один и тот же код запускался по кругу бесконечное количество раз. Для этого существует `while True:`.

```py
counter = 0

while True:

    print(counter)
    counter += 1
```

Программа выше будет бесконечно много раз выводить переменную `counter`, увеличивая ее с каждым разом на единицу, и она никогда не остановится. Прервать этот цикл можно только если закрыть программу принудительно.

> Если вы открыли программу в консоли и хотите принудительно закрыть, но не хотите закрывать окно, то нажмите Ctrl+C, и программа остановится.

## Цикл с условием
### `while <условие>:`

А может, нам хочется сделать не бесконечный цикл, а просто повторить код много раз, или повторять его, пока соблюдено какое-нибудь равенство. Для этого вместо `True` мы можем написать условие:

```py
counter = 0

while counter != 100:

    print(counter)
    counter += 1
```

Этот цикл выведет переменную `counter` сто раз, от 0 до 99, а потом, когда после 99 она станет равна 100, цикл не запустится в очередной раз и программа будет выполняться дальше. 

"While" значит "пока" по-английски. Код внутри цикла while будет выполняться ***пока*** условие соблюдено и перестанет, как только условие нарушится.

> Циклы `while True:` повторяются бесконечно потому что все условия в питоне во время работы программы преобразуются в одно из двух значений: либо `True`, если условие вполняется, либо `False`, если нет. Если вместо условия написать `True`, то это все равно что написать `5 == 5` или `2 > 1`, то есть, написать условие, которое всегда выполняется. Поэтому цикл `while True:` никогда не закончится, т.к. его условие (`True`) никогда не будет нарушено.

---

# Всякое

## Завершение программы
### `exit()`

Ничего сложного. Если мы хотим в какой-то момент чтобы наша программа закрылась и не выполнялась дальше, мы пишем `exit()`.

```py
print("1")
print("2")
exit()
print("3")
```

Цифры 1 и 2 выведутся, а цифра 3 — нет.
